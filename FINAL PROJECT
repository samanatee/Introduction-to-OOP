// Samantha Hangsan
// ID: 900029599
// CS 939 
// FINAL PROJECT

/*//////////////////////////////////////////////////////////////////////////////////////////////
PROJECT SPECS:

The purpose of this project is to take your Midterm project  and  implement it using Random Access Binary Files.
As you recall, the Midterm project used text files to store the data. Here in the final exam project,
you will be storing the data in Random Access Binary File.

Also, in the Midterm project you used Arrays to temporarily hold the data in the memory until the user
decides to write the data to file. Here you will NOT be using Arrays and instead writing the
data directly to Random Access Binary File(This is a must).
Please read the chapter Advance File and I/O operations
before attempting this.

Here is the full description of the Final exam project.

Modify your Midterm Exam Project to:

1. Replace  Employee and Department classes with Employee and Department Structures.

2. Inside each structure, replace all string variables with  array of characters.

3. Make Employee and Department editable. That means, the user should be able to edit a given Employee and Department.

4. Do not allow the user to edit the Employee ID and Department ID.

5. Use Random Access Files to store the data in Binary Form. This means, you should not use an Arrays to
store the data in the memory. Instead, when the user wants to create a new Employee/Department,
you write it to the file right away. Also when the user says he/she wants to edit
an Employee/Department, ask the user to enter EmployeeID/DepartmentID.
Read the data from the file and display it to the user.
Allow the user to enter new data and write it back to the file in the same position inside the file.
Please read the chapter . Advance File/IO operations which has examples on how to do this.

//////////////////////////////////////////////////////////////////////////////////////////////*/


#include <iostream>
#pragma warning(disable:4996)
#include <cstring>
#include <string>
#include <iomanip>
#include <fstream>
#include <limits>
#include <stdlib.h> /* exit, EXIT_FAILURE */
using namespace std;

const int MAX_DEPT = 3, MAX_EMPLOYEE = 7;
const int ID_SIZE = 20, NAME_SIZE = 50;

///* --------------------------------------------DEPARTMENT STRUCTURE-------------------------------------------- *///
struct Department
{
	char departmentID[ID_SIZE];
	char departmentName[NAME_SIZE];
	char departmentHeadName[NAME_SIZE];
};

///* --------------------------------------------EMPLOYEE STRUCTURE-------------------------------------------- *///

//struct Employee
//{
//	// member variables
//	char employeeID[ID_SIZE];
//	char employeeName[NAME_SIZE];
//	double employeeSalary;
//	int employeeAge;
//	char employeeDepartmentID[ID_SIZE];
//
//	// DEFAULT CONSTRUCTOR
//	Employee()
//	{
//		employeeID = "N/A";
//		employeeName = "N/A";
//		employeeSalary = 0.00;
//		employeeAge = 0;
//		employeeDepartmentID = "N/A";
//	}
//	
//	// PROTOTYPES
//	void displayReport(DepartmentArray dptAccess);			// OPTION 5
//};

//void Employee::displayReport(DepartmentArray dptAccess)
//{
//	cout << fixed << showpoint << setprecision(2);
//
//	cout << "\n\n\n                    Salary Report: Total Salary Paid for Each Department\n";
//	cout << "---------------------------------------------------------------------------------------------\n";
//	cout << left << setw(25) << "Department Name:" << left << setw(25) << "Department ID:" << left << setw(25) << "Department Head:" << "Total Salary Paid:" << endl;
//
//	// DEPARTMENT 1
//	double totalDpt1 = 0;
//	for (int index = 0; index < MAX_EMPLOYEE; index++)
//	{
//		if (employeeInfo[index].employeeDepartmentID == dptAccess.departmentInfo[0].departmentID)
//		{
//			totalDpt1 += employeeInfo[index].employeeSalary;
//		}
//	}
//	cout << left << setw(25) << dptAccess.departmentInfo[0].departmentName << left << setw(25) << dptAccess.departmentInfo[0].departmentID << left << setw(25) << dptAccess.departmentInfo[0].departmentHeadName << "$ " << totalDpt1 << endl;
//
//	// DEPARTMENT 2
//	double totalDpt2 = 0;
//	for (int index = 0; index < MAX_EMPLOYEE; index++)
//	{
//		if (employeeInfo[index].employeeDepartmentID == dptAccess.departmentInfo[1].departmentID)
//		{
//			totalDpt2 += employeeInfo[index].employeeSalary;
//		}
//	}
//	cout << left << setw(25) << dptAccess.departmentInfo[1].departmentName << left << setw(25) << dptAccess.departmentInfo[1].departmentID << left << setw(25) << dptAccess.departmentInfo[1].departmentHeadName << "$ " << totalDpt2 << endl;
//
//	// DEPARTMENT 3
//	double totalDpt3 = 0;
//	for (int index = 0; index < MAX_EMPLOYEE; index++)
//	{
//		if (employeeInfo[index].employeeDepartmentID == dptAccess.departmentInfo[2].departmentID)
//		{
//			totalDpt3 += employeeInfo[index].employeeSalary;
//		}
//	}
//	cout << left << setw(25) << dptAccess.departmentInfo[2].departmentName << left << setw(25) << dptAccess.departmentInfo[2].departmentID << left << setw(25) << dptAccess.departmentInfo[2].departmentHeadName << "$ " << totalDpt3 << endl;

//}

/* --------------------------------------------CLIENT PROGRAM-------------------------------------------- */

// GENERAL PROTOTYPES 
void displayMenu();
void chooseOption(Department& departmentInfo, Department* departmentPointer, int& currentDept);

// DEPARTMENT PROTOTYPES
void countDpts(Department departmentInfo, int& currentDept);
long deptByteNum(Department departmentInfo, int structNum);
void createDepartment(Department& departmentInfo, Department* departmentPointer, const int currentDept);
void checkDptID(Department& departmentInfo, Department* departmentPointer, const int currentDept);
void editDepartment(Department& departmentInfo, Department* departmentPointer, const int currentDept);
void departmentRecords(Department departmentInfo);


// EMPLOYEE PROTOTYPES
//void createEmployee(int& currentEmpl, DepartmentArray dptAccess);

int main()
{
	Department departmentInfo = { "N/A", "N/A", "N/A" };
	Department* departmentPointer;
	departmentPointer = &departmentInfo;
	//Employee employeeInfo;

	// FROM MIDTERM 
	char anotherOption;
	//char quitProgram;
	int currentDept = 0;
	int currentEmployee = 0;

	// determine how many departments are already in the file
	countDpts(departmentInfo, currentDept);


	cout << "Choose from the menu below using options 1 through 6. \n\n";
	do
	{
		displayMenu();
		chooseOption(departmentInfo, departmentPointer, currentDept);

		cout << "Would you like to select another option? Enter Y for yes or N for no: ";
		cin >> anotherOption;

		while (anotherOption != 'Y' && anotherOption != 'y' && anotherOption != 'N' && anotherOption != 'n')
		{
			cout << "Press Y for yes or N for No: ";
			cin >> anotherOption;
		}
		cout << endl;

		/*if (anotherOption == 'N' || anotherOption == 'n')
		{
		if (saved == false)
		{
		cout << "You are about to exit the program. The data has not been saved and will be lost.\n";
		cout << "You can save your data by selecting option 3.\n";
		cout << "Do you wish to continue to exit the program? Enter Y for yes or N for no: ";
		cin >> quitProgram;
		while (quitProgram != 'Y' && quitProgram != 'y' && quitProgram != 'N' && quitProgram != 'n')
		{
		cout << "Press Y for yes or N for No: ";
		cin >> quitProgram;
		}
		if (quitProgram == 'Y' || quitProgram == 'y')
		{
		break;
		}
		else if (quitProgram == 'N' || quitProgram == 'n')
		{
		cout << "\nChoose from the menu below using options 1 through 6. \n\n";
		anotherOption = 'Y';
		}
		}
		}*/

	} while (anotherOption != 'N' && anotherOption != 'n');

	// write data to the file, when the user selects this option, dump the info in each array into a separate file
	// RETRIEVE data from file
	// when user selects this OPTION
	// open each file, load the data from the file into the appropriate array
	// DISPLAY REPORT:
	// when user selects this OPTION
	// go through arrays and display TOTAL SALARY paid for each department
	// IF user tries to exit program without saving file
	// ALERT user that data has not been saved and will be lost
	// Proceed only if user consents
	system("pause");
	return 0;
}


/* --------------------------------------------DISPLAY MENU OPTIONS-------------------------------------------- */
void displayMenu()
{
	cout << "MENU\n";
	cout << "----\n";
	cout << "1. Create Department\n";
	cout << "2. Create Employee\n";
	cout << "3. Edit Department\n";
	cout << "4. Edit Employee\n";
	cout << "5. Display Departments\n";
	cout << "6. Display Employees\n";
	cout << "7. Display Salary Report\n";
	cout << "8. Quit the Program\n";
	cout << "----\n";
}

void chooseOption(Department& departmentInfo, Department* departmentPointer, int& currentDept)
{
	int choice;
	cout << "Enter selection: ";
	cin >> choice;

	switch (choice)
	{
	case 1:			// CREATE DEPARTMENT
	{
		if (currentDept < MAX_DEPT)
		{
			createDepartment(departmentInfo, departmentPointer, currentDept);
			currentDept++;
		}
		else
		{
			cout << "You have reached the maximum number of departments that can be created!\n";
			cout << "You may select Option 3 to edit departments or 5 to view existing departments.\n";
		}
		break;
	}
	//case 2:			// CREATE EMPLOYEE
	//{
	//	if (currentEmpl < MAX_EMPLOYEE)
	//	{
	//		emplAccess.createEmployee(currentEmpl, dptAccess);		// number of stored items (max is 7)
	//		currentEmpl++;
	//	}
	//	else
	//	{
	//		// when array is fully, display error message to the user "The array is full, you can not add any more employees"
	//		if (currentEmpl == MAX_EMPLOYEE)
	//		{
	//			cout << "ERROR: The maximum number of employees has been reached, you can not add any more employees!\n";
	//		}
	//	}
	//	break;
	//}
	case 3:			// EDIT DEPARTMENT
	{
		editDepartment(departmentInfo, departmentPointer, currentDept);
		break;
	}
	case 4:		// EDIT EMPLOYEE	
	{
		
		break;
	}
	case 5:			// DISPLAY DEPARTMENTS
	{
		departmentRecords(departmentInfo);
		break;
	}
	case 6:			// DISPLAY EMPLOYEES
	{
		break;
	}
	case 7:			// DISPLAY REPORT
	{
		break;
	}
	case 8:			// QUIT PROGRAM
	{
		char quit;
		cout << "Are you sure you want to exit? Enter Y for yes or N for no: ";
		cin >> quit;

		while (quit != 'Y' && quit != 'y' && quit != 'N' && quit != 'n')
		{
			cout << "Press Y for yes or N for No: ";
			cin >> quit;
		}

		if (quit == 'Y' || quit == 'y')
		{
			cout << "The program will now exit.\n";
			exit(EXIT_SUCCESS);
		}
		else
			break;
		
	}
	// INPUT VALIDATION: only accept valid menu choices 
	default:
	{
		cout << "\nSelect a valid option.\n";
		break;
	}
	}
}

/* --------------------------------------------DETERMINE NUMBER OF DEPARTMENTS IN FILE-------------------------------------------- */
void countDpts(Department departmentInfo, int& currentDept)
{
	int numOfDept = 0;

	// open file for binary reading 
	fstream readFile("departments.dat", ios::in | ios::binary);
	// check for existing file
	if (!readFile)
	{
		currentDept = 0;
	}

	else
	{
		// DEPARTMENT RECORDS
		readFile.read(reinterpret_cast<char *>(&departmentInfo), sizeof(departmentInfo));
		while (!readFile.eof())
		{
			cout << "Department ID: " << departmentInfo.departmentID << endl;
			cout << "Department Name: " << departmentInfo.departmentName << endl;
			cout << "Department Head Name: " << departmentInfo.departmentHeadName << endl;
			cout << endl;
			readFile.read(reinterpret_cast<char *>(&departmentInfo), sizeof(departmentInfo));
			numOfDept++;
		}
		cout << numOfDept;
		currentDept = numOfDept;
	}
	
	readFile.close();
}

/* --------------------------------------------DETERMINE DEPARTMENT BYTE NUMBER FUNCTION-------------------------------------------- */
long deptByteNum(Department departmentInfo, int structNum)
{
	return (sizeof(Department) - sizeof(departmentInfo)) * structNum;
}

/* --------------------------------------------1.) CREATE DEPARTMENT-------------------------------------------- */
void createDepartment(Department& departmentInfo, Department* departmentPointer, const int currentDept)
{
	string input;		// used to read strings

						// create Department file object and open file
	fstream createDpt("departments.dat", ios::out | ios::app | ios::binary);			// if file does not exist, empty file of given name is created
	if (!createDpt)
	{
		cout << "Error opening file. Program will now abort.";
		exit(EXIT_FAILURE);
	}

	// collect all information about a department

	cout << "\n\n---CREATE A DEPARTMENT---\n";
	cout << "Please fill out the following information for the department." << endl;
	cout << "Department ID: ";
	cin.ignore();
	getline(cin, input);
	strcpy(departmentPointer->departmentID, input.c_str());

	/// make sure departmentID does NOT already exist 
	// IF it does NOT, insert Department object into the file
	if (currentDept != 0)
	{
		checkDptID(departmentInfo, departmentPointer, currentDept);
	}
	

	//createDpt.seekg(0, ios::cur);								// sets position in input sentence
																// get new data from user and edit in-memory department record
	// if id is good, continue and create object in array
	cout << "Department Name: ";
	getline(cin, input);
	strcpy(departmentPointer->departmentName, input.c_str());

	cout << "Name of the Head of the Department: ";
	getline(cin, input);
	strcpy(departmentPointer->departmentHeadName, input.c_str());

	// TEST OUTPUT
	cout << departmentInfo.departmentID << endl;
	cout << departmentInfo.departmentName << endl;
	cout << departmentInfo.departmentHeadName << endl;

	createDpt.write(reinterpret_cast<char *>(&departmentInfo), sizeof(departmentInfo));
	createDpt.close();
}

void checkDptID(Department& departmentInfo, Department* departmentPointer, const int currentDept)
{
	Department checkID = { "N/A", "N/A", "N/A" };
	Department dept1 = { "N/A", "N/A", "N/A" };
	Department dept2 = { "N/A", "N/A", "N/A" };
	string input;		// used to read strings
	int deptIndex = 0;	// number of previous departments before the one being created
	

	// open file for binary reading 
	fstream dptRecords("departments.dat", ios::in | ios::out | ios::binary);
	// check for valid file
	if (!dptRecords)
	{
		cout << "Error opening file. The program will now abort.\n";
		exit(EXIT_FAILURE);
	}

	strcpy(checkID.departmentID, departmentInfo.departmentID);

	dptRecords.read(reinterpret_cast<char *>(&departmentInfo), sizeof(departmentInfo));			// read operation reads currently pointed-to structure AND MOVES pointer DOWN ONE STRUCTURE
	streamoff posRead = dptRecords.tellg(); // returns read position
	cout << posRead << endl;
	while (!dptRecords.eof() && deptIndex < currentDept)
	{
		cout << departmentInfo.departmentID << endl;			// check department ID to seek which structure is looked at 
		while (strcmp(checkID.departmentID, departmentInfo.departmentID) == 0)		//COMPARE C STRING
		{
			cout << "That Department ID already exists! Please enter a different department ID.\n";
			cout << "Department ID: ";
			getline(cin, input);
			strcpy(checkID.departmentID, input.c_str());
			for (int index = 0; index < currentDept; index++)
			{
				dptRecords.seekg(sizeof(departmentInfo) * index);
				dptRecords.read(reinterpret_cast<char *>(&departmentInfo), sizeof(departmentInfo));
				if (strcmp(checkID.departmentID, departmentInfo.departmentID) == 0)
				{
					break;
				}
			}
		}
		dptRecords.read(reinterpret_cast<char *>(&departmentInfo), sizeof(departmentInfo));
		deptIndex++;
	}
	
	cout << posRead << endl;
	strcpy(departmentInfo.departmentID, checkID.departmentID);


	departmentRecords(departmentInfo);
}

/* --------------------------------------------2.) CREATE EMPLOYEE FUNCTION-------------------------------------------- */
//void createEmployee(int& currentEmpl, DepartmentArray dptAccess)
//{
//	// create Employee file object and open file
//	fstream employeeFile("employees.txt", ios::out | ios::binary);
//	if (!employeeFile)
//	{
//		cout << "Error opening file. Program will now abort.";
//		exit(EXIT_FAILURE);
//	}
//	// collect all information about an employee
//	cout << "\n\n---CREATE AN EMPLOYEE---\n";
//	cout << "Please fill out the following information for the employee." << endl;
//	cout << "Employee ID: ";
//	cin.ignore();
//	getline(cin, employeeInfo[currentEmpl].employeeID);
//
//	/// make sure employeeID does NOT already exist in the array containing Department objects
//	// IF it does NOT, insert Employee object into the array
//	if (currentEmpl != 0)
//	{
//		for (int previous = 0; previous < currentEmpl; previous++)
//		{
//			while (employeeInfo[currentEmpl].employeeID == employeeInfo[previous].employeeID)
//			{
//				cout << "That Employee ID already exists! Please enter a different Employee ID.\n";
//				cout << "Employee ID: ";
//				getline(cin, employeeInfo[currentEmpl].employeeID);
//			}
//		}
//	}
//	// if id is good, continue and create object in array
//	cout << "Employee Name: ";
//	getline(cin, employeeInfo[currentEmpl].employeeName);
//
//	cout << "Employee Salary: $";
//	cin >> employeeInfo[currentEmpl].employeeSalary;
//
//	cout << "Employee Age: ";
//	cin >> employeeInfo[currentEmpl].employeeAge;
//
//	cout << "Employee Department ID: ";
//	cin.ignore();
//	getline(cin, employeeInfo[currentEmpl].employeeDepartmentID);
//
//	bool match = false;
//
//	while (match == false)
//	{
//		for (int previous = 0; previous < MAX_DEPT && match == false; previous++)
//		{
//			if (employeeInfo[currentEmpl].employeeDepartmentID == dptAccess.departmentInfo[previous].departmentID)
//			{
//				match = true;
//				break;
//			}
//			else
//			{
//				match = false;
//			}
//		}
//
//		if (match == false)
//		{
//			cout << "That Department ID does not exist! Please enter a valid Employee Department ID.\n";
//			cout << "Employee Department ID: ";
//			getline(cin, employeeInfo[currentEmpl].employeeDepartmentID);
//		}
//	}
//}

/* --------------------------------------------3.) EDIT DEPARTMENT-------------------------------------------- */
void editDepartment(Department& departmentInfo, Department* departmentPointer, const int currentDept)
{
	departmentPointer = &departmentInfo;
	Department edit = { "N/A", "N/A", "N/A" };
	long deptNum;			// edit this department
	string input;			// user input
	streamoff desiredPos;	// position to write to 
	
	// open file for binary reading 
	fstream editDpt("departments.dat", ios::in | ios::out | ios::binary);
	// check for valid file
	if (!editDpt)
	{
		cout << "Error opening file. The program will now abort.\n";
		exit(EXIT_FAILURE);
	}

	departmentRecords(departmentInfo);

	// move to desired department and read it 
	cout << "Please enter the department ID of the department you want to edit: ";
	cin.ignore();
	getline(cin, input); 
	strcpy(edit.departmentID, input.c_str());

	streamoff posRead = editDpt.tellg(); // returns read position
	cout << posRead << endl;
	editDpt.read(reinterpret_cast<char *>(&departmentInfo), sizeof(departmentInfo));			// read operation reads currently pointed-to structure AND MOVES pointer DOWN ONE STRUCTURE
	long deptIndex = 0;
	while (!editDpt.eof())
	{
		cout << departmentInfo.departmentID << endl;			// check department ID to seek which structure is looked at 
		if (strcmp(edit.departmentID, departmentInfo.departmentID) == 0)		//COMPARE C STRING
		{
			deptNum = deptIndex;								// determine which structure matches this department ID
			desiredPos = posRead;								// determine starting position of structure to edit
			break;
		}
		deptIndex++;
		streamoff posRead = editDpt.tellg(); // returns read position
		cout << posRead << endl;
		editDpt.read(reinterpret_cast<char *>(&departmentInfo), sizeof(departmentInfo));
	}

	editDpt.seekg(0, ios::cur);								// sets position in input sentence
	// get new data from user and edit in-memory department record
	cout << "Old Department Name: ";
	cout << departmentInfo.departmentName << endl;
	cout << "New Department Name: ";
	getline(cin, input);
	strcpy(departmentPointer->departmentName, input.c_str());
	cout << "\nOld Department Head Name: ";
	cout << departmentInfo.departmentHeadName << endl;
	cout << "New Department Head Name: ";
	getline(cin, input);
	strcpy(departmentPointer->departmentHeadName, input.c_str());

	streamoff posWrite = editDpt.tellg();										// sets position where next charater is to be inserted into the output stream
	editDpt.seekp(posWrite - sizeof(departmentInfo));

	editDpt.write(reinterpret_cast<char *>(&departmentInfo), sizeof(departmentInfo));
	editDpt.close();

	departmentRecords(departmentInfo);

	
}

/* --------------------------------------------5.) DISPLAY DEPARTMENT RECORDS-------------------------------------------- */

void departmentRecords(Department departmentInfo)			// ALL DEPARTMENT RECORDS
{
	// open file for binary reading 
	fstream dptRecords("departments.dat", ios::in | ios::binary);
	// check for valid file
	if (!dptRecords)
	{
		cout << "Error opening file. The program will now abort.\n";
		exit(EXIT_FAILURE);
	}

	// DEPARTMENT RECORDS
	cout << "\nDEPARTMENT RECORDS\n";
	cout << "------------------\n";
	dptRecords.read(reinterpret_cast<char *>(&departmentInfo), sizeof(departmentInfo));
	while (!dptRecords.eof())
	{
		cout << "Department ID: " << departmentInfo.departmentID << endl;
		cout << "Department Name: " << departmentInfo.departmentName << endl;
		cout << "Department Head Name: " << departmentInfo.departmentHeadName << endl;
		cout << endl;
		dptRecords.read(reinterpret_cast<char *>(&departmentInfo), sizeof(departmentInfo));
	}
	dptRecords.close();
}

/* --------------------------------------------6.) DISPLAY EMPLOYEE RECORDS-------------------------------------------- */
